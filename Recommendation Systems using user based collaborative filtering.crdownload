# -*- coding: utf-8 -*-
"""Recommendation Systems using user based collaborative filtering.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1jILMJ7Jnp5WUu3bUgssZkdp_5m7o91UH
"""

pip install scikit-surprise

from surprise import Dataset, Reader, KNNBasic
from surprise.model_selection import train_test_split
from surprise import accuracy
import pandas as pd

# Sample user-item ratings data
data = [
    ('User1', 'Item1', 4.0),
    ('User1', 'Item2', 3.0),
    ('User1', 'Item3', 2.0),
    ('User2', 'Item1', 3.0),
    ('User2', 'Item2', 4.0),
    ('User2', 'Item3', 1.0),
    ('User3', 'Item1', 5.0),
    ('User3', 'Item2', 4.0),
    ('User3', 'Item3', 2.0),
    ('User4', 'Item2', 2.0),
    ('User2', 'Item6', 3.0),
    ('User3', 'Item5', 4.0),
    ('User2', 'Item3', 1.0),
]

# Create a DataFrame from the sample data
df = pd.DataFrame(data, columns=['user', 'item', 'rating'])

# Create a reader to parse the data
reader = Reader(rating_scale=(1, 5))

# Load the dataset from the DataFrame
data = Dataset.load_from_df(df[['user', 'item', 'rating']], reader)

# Split the data into train and test sets
trainset, testset = train_test_split(data, test_size=0.2, random_state=42)

# Build a user-based collaborative filtering model
sim_options = {
    'name': 'cosine',
    'user_based': True
}

model = KNNBasic(sim_options=sim_options)

# Train the model on the training set
model.fit(trainset)

# Make predictions on the test set
predictions = model.test(testset)

# Evaluate the model's performance
rmse = accuracy.rmse(predictions)
mae = accuracy.mae(predictions)

print(f'RMSE: {rmse:.2f}')
print(f'MAE: {mae:.2f}')

# Recommend items for a specific user
user_to_recommend = 'User1'
items_to_ignore = df[df['user'] == user_to_recommend]['item'].tolist()

# Get top N recommendations
user_predictions = []
for uid, iid, true_r, est, _ in predictions:
    if uid == user_to_recommend:
        user_predictions.append((iid, est))

# Sort the user's predictions by estimated rating in descending order
user_predictions.sort(key=lambda x: x[1], reverse=True)

# Display the top N recommended items
top_n = 5
recommended_items = [item for item, _ in user_predictions if item not in items_to_ignore][:top_n]

print(f'Recommended items for {user_to_recommend}: {recommended_items}')

from surprise import Dataset, Reader, KNNBasic
import pandas as pd

# Updated user-item ratings data with more interactions
data = [
    ('User1', 'Item1', 4.0),
    ('User1', 'Item2', 3.0),
    ('User1', 'Item3', 2.0),
    ('User2', 'Item1', 3.0),
    ('User2', 'Item2', 4.0),
    ('User2', 'Item3', 3.0),
    ('User3', 'Item1', 5.0),
    ('User3', 'Item2', 4.0),
    ('User3', 'Item3', 2.0),
    ('User4', 'Item1', 4.0),
    ('User4', 'Item2', 5.0),
    ('User4', 'Item3', 4.0),
    ('User1', 'Item4', 4.0),  # New interactions for User1
    ('User1', 'Item5', 3.0),  # New interactions for User1
]

# Create a DataFrame from the updated data
df = pd.DataFrame(data, columns=['user', 'item', 'rating'])

# Create a reader to parse the data
reader = Reader(rating_scale=(1, 5))

# Load the dataset from the DataFrame
data = Dataset.load_from_df(df[['user', 'item', 'rating']], reader)

# Build a user-based collaborative filtering model
sim_options = {
    'name': 'cosine',
    'user_based': True
}

model = KNNBasic(sim_options=sim_options)

# Train the model on the entire dataset
trainset = data.build_full_trainset()
model.fit(trainset)

# Recommend items for User1
user_to_recommend = 'User3'
items_rated_by_user = df[df['user'] == user_to_recommend]['item'].tolist()

# Get a list of all items
all_items = df['item'].unique()

# Remove items already rated by User1 from the list of all items
items_to_recommend = [item for item in all_items if item not in items_rated_by_user]

# Predict ratings for the items to recommend
predictions = [model.predict(user_to_recommend, item) for item in items_to_recommend]

# Sort the recommendations by predicted rating in descending order
sorted_recommendations = sorted(predictions, key=lambda x: x.est, reverse=True)

# Display the top N recommended items
top_n = 5
recommended_items = [(prediction.iid, prediction.est) for prediction in sorted_recommendations][:top_n]

recommended_item_names = [item for item, _ in recommended_items]

print(f'Recommended items for {user_to_recommend}: {recommended_item_names}')